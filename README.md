
# pair_macro [![crates.io](https://img.shields.io/crates/v/pair_macro.svg)](https://crates.io/crates/pair_macro) [![Build Status](https://travis-ci.org/Amelia10007/pair_macro.svg?branch=master)](https://travis-ci.org/Amelia10007/pair_macro)

Create types consisting of the same type values such that Pair, Triplet, and so on.

This crate runs on `no-std` environment.

## Examples
### Use a provided type `Pair<T>`.
```rust
use pair_macro::Pair;

let p = Pair::new(1.0, 2.0); // Pair<f64>
let q = p.map(|v| v * 2.0);

assert_eq!(Pair::new(2.0, 4.0), q);

// `Pair<T>` has `x` and `y` fields
assert_eq!(2.0, q.x);
assert_eq!(4.0, q.y);
```

### Create a new pair type.
```rust
use pair_macro::create_pair_prelude::*;

create_pair!(MyOwnPair; a, b, c, d);

let p = MyOwnPair::new(1, 2, 3, 4); // MyOwnPair<i32>
let q = MyOwnPair::new(5, 6, 7, 8);
let r = p + q;

// `MyOwnPair<T>` has `a`, `b`, `c` and `d` fields
assert_eq!(6, r.a);
assert_eq!(8, r.b);
assert_eq!(10, r.c);
assert_eq!(12, r.d);
```

### Use provided methods
```rust
use core::str::FromStr;
use pair_macro::Pair;

let p = Pair::new(["hello", "42"], ["world", "58"]); // Pair<[&str; 2]>
let value = p
    .as_ref()            // Pair<&[&str; 2]>
    .map(|strs| strs[1]) // Pair<&str>
    .map(i32::from_str)  // Pair<Result<i32, Error>>
    .into_result()       // Result<Pair<i32>, Error>
    .unwrap()            // Pair<i32>
    .into_iter()         // Iterates each value in the pair (`42` and `58` in this situation)
    .sum::<i32>();       // 42 + 58

assert_eq!(100, value);
```

Of course, your original pair types defined by `create_pair!` macro have the same methods.

## Features
Pair types support [serde](https://crates.io/crates/serde) by enabling `serde` feature: in your `Cargo.toml`,  
```
pair_macro = { version = "0.1.4", features = ["serde"] }
```

## Note
Pair types' documentation may be slightly hard to read since it is generated by macro expansion.

License: MIT
